# 数据结构和算法



### 1 前缀和

```
作用：
	可以快速求出一维数组中某一段和或者二维数组中子矩阵和
```



### 2 差分

```
概念：
	对于数组 a1, a2, a3, .., 构造数组 b1, b2, b3, ..
	使得 ai = b1 + b2 + b3 + ... + bi
	
	note: b数组为a的差分，a数组为b数组的前缀和

构造:
	b1 = a1
	b2 = a2 - a1
	b3 = a3 - a2
	
作用:
	如果需要对 a 数组中某一段 l-r 进行统一的 +c 操作
	现在只需要做 b[l] + c, b[r+1] - c, 两个操作即可
	
另一种构造方式:
	(这种方式比较通用, 将 a[i]单个节点看成c ，思路也可以适用于二维数组)
	可以将a数组都看成0, 然后构造b数组也都是0，开始构造b数组，
	for(i=0; i < len; i++){
		b[i] = b[i] + a[i]
		b[i+1] = b[i+1] - a[i]
	}
	note: 需要考虑边界问题
	
扩展：
	二维差分
```



### 3 离散化

```c++
/*
	区间很大，但是个数相对来说较少
	
	例题：
		求区间和,
		假定一个无限长的数轴，数轴上每个点都是0.
		现在进行n次操作，每次操作将某一位置x的数加c。
		再进行m此询问，每次询问包含两个整数l和r，求出l和r之间所有数之和
		
	步骤：
	 	1.将所有需要离散化的数据（如下面例子中的下标）放到一个容器中（以下使用vector，当然可以用数组代替）；
　　	   2.排序，去重（可以手写，也可以用STL的algorithm库中的unique函数）；
　　	   3.要查询原数据在容器中的位置只需在容器中二分查找第一个大于等于该数据的数的位置即可。
 */
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 100010;

vector<int> alls;

int n, m;
int x[N], c[N], l[N], r[N];
int a[N * 3], s[N * 3];

// 找到x在alls中的下标
int find(int x)
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}


int main(){

    // n 表示 n 个数据， m 表示 m个 [l, r] 求和操作
    scanf("%d%d", &n, &m);

    // x 表示坐标， c 表示值
    for (int i = 0; i < n; i ++ ){
        scanf("%d%d", &x[i], &c[i]);
        alls.push_back(x[i]);
    }

    for (int i = 0; i < m; i ++ ){
        scanf("%d%d", &l[i], &r[i]);
        alls.push_back(l[i]), alls.push_back(r[i]);
    }

    // 对 alls 排序 + 判重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());

    // 插入操作
    for (int i = 0; i < n; i ++ ) a[find(x[i])] += c[i];

    // 预处理前缀和(s 数组为 a 数组的前缀和数组)
    for (int i = 1; i <= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];

    // 查询操作
    for (int i = 0; i < m; i ++ ) printf("%d\n", s[find(r[i])] - s[find(l[i]) - 1]);


    return 0;
}
```

